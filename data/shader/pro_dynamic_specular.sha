///////////////////////////////////////////////////////////////////////////
// pro_dynamic_specular.sha
///////////////////////////////////////////////////////////////////////////
// Copyright (c) 2005 Bugbear Entertainment ltd. 
// All Rights Reserved.
// 
// Created on 16.11.2005 11:21:44
// 
// Authors: Tatu Blomberg (tatu@bugbear.fi)
///////////////////////////////////////////////////////////////////////////
Texture	Tex0;
Texture	Tex1;

const string inputStreamFormat = "PosNormTex1";

vertexshader vSdr = 
	decl
	{
		stream 0;
		float    v0[3];		// Position
		float	 v1[3];		// Normal
		float    v3[2];		// Tex coord 0
	}
	asm
	{
        ; Constants:
        ;  0..3 - Composite World-View-Projection Matrix
		;  4..7 - World Matrix
		vs.1.1
		
		dcl_position	v0
		dcl_normal		v1
		dcl_texcoord	v3
		
		// passthru texture coords
		mov		oT0.xy, v3.xy

		// project position
		m4x4	oPos, v0, c0
		// rotate normal
		m3x3	r0.xyz, v1, c4
		mov		oT1.xyz, r0
		// SH lighting
		mov		r0.w, c15.z		; w = 1.0
		dp4		r1.x, r0, c17
		dp4		r1.y, r0, c18
		dp4		r1.z, r0, c19
		; gamma correction
		rsq		r1.x, r1.x
		rsq		r1.y, r1.y
		rsq		r1.z, r1.z
		rcp		oD0.x, r1.x
		rcp		oD0.y, r1.y
		rcp		oD0.z, r1.z
		
		
		; position -> world
		m4x3	r1.xyz, v0, c4
		
		; vtx -> eye			
		sub		r2.xyz, c8, r1		
		; normalize it
		dp3		r2.w, r2, r2
		rsq		r2.w, r2.w
		mul		r2.xyz, r2.xyz, r2.w
		; r2.xyz = vtx->eye
		
		; compute h vector
		add		r3.xyz, r2, c20
		dp3		r3.w, r3, r3
		rsq		r3.w, r3.w
		mul		r3.xyz, r3.xyz, r3.w

		; r3 = h
				
		; Dot(n,h)
		dp3		r0.w, r0, r3
		sge		r2.x, r0.w, c32.w	; 1 if >= 0
		; Dot(n,l)
		dp3		r1.w, r0, c20
		sge		r2.y, r1.w, c32.w	; 1 if >= 0
		mul		r2.x, r2.x, r2.y
		mul		r0.w, r0.w, r2.x
		
		
		mul		r1.w, r0.w, r0.w
		mul		r1.w, r1.w, r1.w
		mul		r1.w, r1.w, r1.w

		mul		oD1, c22, r1.w		; specular
		
		
	};

pixelshader pSdr =
	asm
	{
		ps.1.1

		; fetch texture
		tex		t0		; base color
		tex		t1		; diffuse lookup from cubemap


;		mov	r0.rgb, v0
		; = diffuse + ambient
		mad_d2	r0.rgb, t1.a, c2, v0
		; passthru alpha
		+mov	r0.a, t0.a
		; limit overlighting
		mul_sat	r0.rgb, r0, c1
		mul_sat	r0.rgb, r0, c1.a
		; modulate texel color
		mul_x2_sat	r0.rgb, r0, t0
		mad_sat	r0.rgb, t0.a, v1, r0
;		add_sat	r0.rgb, r0, v1
		


	};

Technique T0
{
    Pass P0
    {        
    
		VertexShaderConstantF[32] = float4( 5.0f, 0.0f, 0.0f, 0.0f );		    
		Texture[0] = <Tex0>;
		Texture[1] = <Tex1>;
		
				
		VertexShader = <vSdr>;
		PixelShader = <pSdr>;
	}
}